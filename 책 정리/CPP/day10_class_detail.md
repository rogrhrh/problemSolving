# chapter 11

> ### 연산자 오버로딩

    - 기본적으로 연산자를 이용한 사용자 정의 객체의 사칙연산은 바로 사용 할 수없다.
    - operator연산자() 를 사용하여 연산자를 오버로딩해 사용할 수 있다.
    - 연산자 오버로딩 후 연산자를 사용하면 컴파일러가 연산자를 연산자 함수로 대체한다.
    ex) Stock operator+(const Stock & s) const;
        {
            Stock temp;
            temp.val1 = this->val1 + s.val1;
            temp.val2 = this->val2 + s.val2;

            retrun temp;
        }

> ### 오버로딩 제약

    - 오버로딩된 연산자는 적어도 하나의 피연산자가 사용자 정의 데이터 형이여야 한다.
        -- 이는 표준 데이터형을 위해 사용되는 연산자를 오버로딩 하는것을 막아준다.
    - 오버로딩된 연산자를 오리지널 연산자에 적용되는 문법 규칙을 위반하는 방식으로 사용할 수 없다.
        -- ex)하나의 피연산자에만 적용 가능한 %연산자는 만들 수 없다.
        -- 정해진 연산자 우선순위도 변경 할 수 없다.
    - 연산자 기호를 새로 만들 수 없다.
    - 'sizeof', '.', '.*', '::', '?:' 등의 연산자는 오버로딩 할 수 없다.
    - 'typeid', 'const_cast', 'dynamic_cast', 'reinterpret_cast', 'static_cast'도 마찬가지
    - '=', '()', '[]', '->' 연산자는 멤버 함수만 사용할 수 있다.

> ### 프렌드
    
    - 프렌드 함수, 프렌드 클래스, 프렌드 멤버 함수
    - 클래스의 private 멤버에 접근할 수 있는 권한을 준다.
    - 클래스 선언에 friend를 붙여 함수의 원형을 선언해준다.
    - 이후 함수를 정의할때 외부함수 처럼 범위 지정자 없이 정의하고 사용한다.
    - 멤버 함수와 동등한 접근 권한을 가지는 멤버가 아닌 함수가 된다.

> #### note) 프렌드는 oop에 어울리지 않는다?
    
    - 데이터 은닉을 위반하는 것처럼 보인다.
    - 프렌드 함수는 클래스를 위한 확장 인터페이스의 일부라고 생각해야한다.
    - 클래스 함수와 프랜드 함수는 클래스 인터페이스를 나타내는 서로다른 메커니즘이다.