# chapter 11

> ### 연산자 오버로딩

    - 기본적으로 연산자를 이용한 사용자 정의 객체의 사칙연산은 바로 사용 할 수없다.
    - operator연산자() 를 사용하여 연산자를 오버로딩해 사용할 수 있다.
    - 연산자 오버로딩 후 연산자를 사용하면 컴파일러가 연산자를 연산자 함수로 대체한다.
    ex) Stock operator+(const Stock & s) const;
        {
            Stock temp;
            temp.val1 = this->val1 + s.val1;
            temp.val2 = this->val2 + s.val2;

            retrun temp;
        }

> ### 오버로딩 제약

> ### 프렌드
    
    - 프렌드 함수, 프렌드 클래스, 프렌드 멤버 함수
    - 클래스의 private 멤버에 접근할 수 있는 권한을 준다.
    - 클래스 선언에 friend를 붙여 함수의 원형을 선언해준다.
    - 이후 함수를 정의할때 외부함수 처럼 범위 지정자 없이 정의하고 사용한다.
    - 멤버 함수와 동등한 접근 권한을 가지는 멤버가 아닌 함수가 된다.

> #### note) 프렌드는 oop에 어울리지 않는다?
    
    - 데이터 은닉을 위반하는 것처럼 보인다.
    - 프렌드 함수는 클래스를 위한 확장 인터페이스의 일부라고 생각해야한다.
    - 클래스 함수와 프랜드 함수는 클래스 인터페이스를 나타내는 서로다른 메커니즘이다.