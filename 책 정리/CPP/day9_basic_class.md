chapter 10

> OOP의 중요 기능들
추상화 abstraction
캡슐화 encapsulation
데이터은닉 data hiding
다형성 polymorphism
상속 inheritance
코드의 재활용 reusability of code

> 추상화 abstraction
	정보를 사용자 인터페이스로 표현한다.
	어떤 문제에 필수적인 조작적 기능들을 추상화하고 그것으로 해결책을 표현한다.

> 클래스
	추상화를 사용자 정의 데이터형으로 변환해 주는 c++의 수단
	클래스 선언, 클래스 메서드 정의
	멤버 표현시 m_data같은 형식으로 표현한다.
	기본은 private 멤버로 선언됨, (구조체는 기본이 public)
	접근제어자 : public, private 
	private 선언된 멤버는 클래스 외부에서 직접 접근이 불가능하다. (혹은 friend 선언)
	public의 함수로 private멤버들에 접근하는 방식을 data hiding이라 한다.
	
	public인터페이스와 세부적인 구현을 분리한다.
	인터페이스는 설계의 추상화를 나타내고 세부구현은 따로 결합하여
	추상화와 분리하는 것을 캡슐화 (encapsulation) 이라고 한다.
	데이터 은닉은 캡슐화의 한 예가 된다.
	클래스 함수 정의를 클래스 선언과 독립된 파일에 넣는것도 캡슐화이다.

	데이터 은닉(data hiding)은 데이터 표현이 어떻게 되어 있는지에 대해 클래스 사용자가
	신경쓰지 않도록 해 준다. 사용자 입장에서는 매개변수와 리턴하는 값의 종류만 알면 된다.
	클래스 관리자 입장에서 코드를 수정할때 프로그램 인터페이스는 그대로 두고 세부 구현만
	변경할 수 있다.

	클래스를 일반적으로 클래스 서술하는데 사용하고 순수한 데이터 객체를 정의하는 데에는
	구조체를 사용한다. (plain-old-data POD구조가 되는 데이터 객체들 --> 구조체 사용)
> POD(plain old data)
	데이터 자체로 취급 할 수 있는 개체
	복잡한 레이아웃을 가지지 않는다, 표준 레이아웃 타입
	유저가 정의한 복사 의미론은 가지지 않는다.
	간단한 기본 생성자를 가지고 있다, 간단한 타입
	
note) 인터페이스?
	프로그램 인터페이스는 사용자의 의도를 컴퓨터에 저장 되어 있는 특정 정보로 변환하는 것을 담당
	클래스 관련, public 인터페이스는 프로그래머가 클래스 객체와 상호 작용 가능한 부분을 의미한다,

> 클래스 멤버 함수의 구현
	각각의 함수머리와 하나의 함수 몸체를 가진다.
	어떤 클래스에 속하는지 scope연산자(::)를 사용하여 표현한다. 사용범위 결정 연산자.
	ex)void Stock::update(double price)
	Stock 클래스의 void 리턴형의 double형 매개변수를 가지는 updata 함수
	클래스 선언을 헤더파일에, 클래스 멤버 함수 정의들을 독립된 소스 코드 파일에 넣는다
	(템플릿을 사용할 경우 선언과 정의가 함께 있어야 한다)
	클래스 선언 안에 정의를 가지고 있는 모든 함수는 자동으로 인라인 함수가 된다.
	짧은 멤버 함수에 대해서는 인라인 함수로 사용하자 외부로 빼면 inline 제한자를 붙이자
	클래스 선언 안에 메서드를 정의하는 것은 메서드 정의를 원형으로 대체하고,
	클래스 선언 바로 뒤에 메서드 정의를 인라인 함수로 작성하는 것과 같다.

note) 클래스의 메모리상 위치
	생성된 각 객체의 변수들은 독립된 저장 공간을 가진다. 하지만 멤버 함수들은 동일한
	메모리상 위치를 공유한다. 

note) 클라이언트-서버 모델
	클라이언트는 클래스를 사용하는 프로그램,
	클래스 메서드를 포함하여, 클래스 선언이 서버를 구성한다.
	서버는 그것을 필요로 하는 프로그램들이 사용할 수 있는 리소스,
	클라이언트는 public으로 정의된 인터페이스를 통해서만 서버를 사용한다.
	따라서 클라이언트는 그 인터페이스를 이해하는것만 하면 된다.
	서버는 서버가 그 인터페이스에 따라 신뢰성이 있고 정확하게 수행되는지 확인하는 것이다.
	서버관리자는 인터페이스가 아니라 세부 구현부를 변경해야한다.	

> 실행상의 변경
	멤버 함수 내에서 표현방식의 변경이 필요할 경우(예를들어 cout의 소수점 표현)
	클라이언트 프로그램의 다른 부분에 대하여 영향을 주어서는 안된다.
	따라서 변경이 있는 함수가 호출될 경우 원래 상태를 저장하고 함수를 진행하고
	함수가 종료되기 전에 원래 상태로 돌려줘야 한다.

> 생성자와 소멸자
	클래스 객체는 실체가 없다.
	인스턴스로 만든다. -> 실체를 부여(메모리상에 올린다)
	생성자와 소멸자는 인스턴스가 생성될때 자동으로 호출되는 표준 함수 들이다.
	--생성자
		생성자는 데이터형이 없고 클래스 이름이 같은 형태이다
		멤버 변수들 초기화, 초기화 리스트를 사용할 경우 생성과 동시화 초기화된다.
		초기화 함수를 만들어 생성자에 넣어도 괜찮다, (특정 시점에 호출할 경우)
		명시적 호출(생성자를 함수처럼 호출한다, 리턴값이 인스턴스처럼 사용)
		암시적 호출(인스턴스 뒤에 바로 괄호로 생성자 호출)
	--디폴트 생성자
		명시적인 초기화 값을 제공하지 않을 때, 객체를 생성하는데 사용하는 생성자
		멤버들이 초기화 되지 않은 객체를 생성한다.
		사용자가 어떤 생성자를 정의한 경우 컴파일러는 자동으로 디폴트 생성자를 만들지 않는다.
		1. 생성자의 모든 매개변수에 디폴트 값을 제공
		2. 매개변수가 없는 디폴트 생성자를 정의
		하는 방법으로 명시적으로 표현해야 한다 (두개다 쓸수는 없다, 모호함)
	--소멸자, 파괴자
		객체의 수명이 끝나는 시점에서 호출되어 동적할당한 값을 삭제해줘야한다.
		매개변수를 가지면 안된다. ~클래스명() 으로 선언
		삭제 뿐 아니라 객체가 끝나는 시점에서 진행할 동작들을 설정해 줘도 좋다.
		사용자가 명시적으로 소멸자를 호출해서는 안된다.
		소멸자는 코드 블럭을 넘어가며 호출된다.
	stock1 = Stock("temp",1, 1.2);
	이미 존재하는 stock1에 새로운 값을 대입하는 경우, 생성자가 임시 객체를 생성한 뒤
	새로 생성된 임시 객체의 내용이 stock1에 복사된다. 다음줄에서 바로 임시 객체의 수명이 끝나므로
	임시객체의 소멸자가 호출된다.
	
	{} 값을 이용하는 리스트 초기화도 가능하다, 순서에 따라 생성자의 각 매개변수에 매칭된다.
	--const 멤버함수
		void show() const //호출 객체를 변경하지 않는다고 약속한다.	

note) 멤버이름과 매개변수 이름
 클래스 멤버 이름을 생성자의 매개변수로 사용하지 말 것, 멤버 변수를 'm_' 을 써서 나타내 봅시다

> this 포인터
	자기 자신을 호출하는 포인터
	객체가 멤버함수에서 자기자신을 리턴할때 보통 사용한다.
	같은 종류의 객체의 인스턴스를 매개변수로 받아오는 경우 구분을 위해 this를 사용하는 경우도 있다.

> 객체 배열
	생성자를 사용할 경우 각각 배열 원소들에 대해 생성자를 호출해야 한다.
	생성자가 여러개인 경우 각 원소마다 다른 생성자를 호출 할 수 있다.

> 클래스 사용 범위
	상수선언
		1. 열거체 사용 enum{Month = 12};
		2. static const int Month =12; 사용
	범위가 정해진 열거	
		클래스를 사용해서 enum을 쓰면 범위가 지정된 열거형이 된다.
		enum class temp {A, B, C, D};
	
> 추상화 데이터형 (Abstract data type)
	ADT 는 언어나 시스템의 세부적인 것들을 따지지 않고, 데이터형을 일반적인 형식으로 서술한다.
	stl 같은거를 ADT로 많이 표현한다. 어떻게 사용하면 되는지, 뭐하는 함수인지 설명하는거에
	중점을 맞춘다.

	