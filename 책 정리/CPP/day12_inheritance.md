# chapter 13

> ### 클래스의 상속

    - 기본개념 -> 코드의 재사용을 극대화 하기 위해서 사용
    - 기존 클래스에 기능을 좀더 붙인 확장 클래스를 만들자
    - 기초 클래스, 부모 클래스에서 상속받은 파생 클래스, 자식 클래스
    - 부모 클래스의 public 멤버들은 자식 클래스의 public 멤버가 된다.
        -- 자식 클래스는 자기 자신의 생성자가 필요하다.
        -- 자식 클래스는 부가적인 멤버를 추가 할 수 있다.
    - 부모 클래스의 private도 상속 되지만 직접 접근 할 수 없다.
        -- 부모 클래스의 메서드에서 접근하는 방식을 사용

> ### 상속간 생성자

    - 컴파일러는 자식 클래스의 객체를 생성할 때, 부모 클래스 객체를 먼저 생성한다.
    - 멤버 초기자 리스트 문법을 사용한다.
    - 자식 클래스 생성자에 부모 클래스 초기화 리스트가 없다면 
      부모클래스의 기초 생성자를 자동으로 사용한다
        -- 다른 생성자가 있어 기초 생성자가 명시되지 않았다면 오류
    - 소멸은 생성의 역순 자식이 먼저 삭제되고 부모가 삭제된다.

> ### 자식 클래스와 부모 클래스

    - private가 아닌 protectd, public 멤버에 접근 가능
    - 부모 클래스 포인터는 명시적 데이터형 변환 없이 자식 클래스를 가리킬 수 있다.
    - 부모 클래스의 참조는 명시적 데이터형 변환 없이 자식 클래스를 가리킬 수 있다.
    - 하지만 부모 클래스의 포인터나 참조는 자식 클래스의 멤버는 호출 할 수 없다.
        -- 자식 클래스의 부모 부분만 사용 가능하다.
    - 자식 클래스의 포인터, 참조는 부모 클래스를 가리킬 수 없다.
    
    - 기초 클래스의 참조와 포인터를 매개 변수로 사용한 함수는
      부모 객체, 자식 객체 둘다 매개 변수로 사용 가능하다.
    - 기초 클래스를 자식 클래스로 초기화 할 수 있다, 자식 클래스를 가리키는
      부모 클래스형 참조자가 암시적으로 생성되어 값을 받아온다.
    - 대입도 마찬가지

> ### is - a 관계

    - ~는 ~다 라는 개념을 적용 할 수 있다면 상속 관계로 설계를 고려하자
    - 비슷하게 has - a 관계가 있는데, 포함이 되는 경우 멤버로 넣는 설계를 고려

> ### public 다형 상속

    - 호출하는 객체에 따라 메서드의 행동이 달라질 수 있다.
    - 다형성을 허용하려면, 자식 클래스에서 다시 정의하거나 가상 메서드를 사용
    - virture을 붙여 다형성을 허용 한다.
    - virture일 경우 자식 클래스에서 해당 메서드를 다시 정의 할 수 있다.
    - 이경우 부모 클래스 참조나 포인터로 해당 메서드에 접근할때 자식 메서드를 참조할 수 있다.

> ### virtual

    - 부모 클래스에서 클래스 메서드 선언시 virtual로 시작하면 가상 함수가 된다.
    - 객체에 대한 참조 또는 포인터를 사용해서 가상 함수를 호출하면, 
      참조나 포인터형을 위해 정의된 메서드가 아닌 객체형을 위해 정의된 메서드 사용
       -- 이를 동적결합이라 한다.
    - 자식 클래스에서 다시 정의하는 메서드는 가상 메서드로 선언한다.

    - 생성자
        -- 생성자는 가상으로 선언 할 수 없다.
        -- 자식 클래스 객체의 생성은 자식 클래스의 생성자가 부모 클래스의 생성자를 호출
        -- 이 시퀀스는 상속 메커니즘과 다르다, 생성자를 상속 받지 않는다.
    
    - 파괴자
        -- 소멸자를 필요로 하는 클래스가 상속된다면 소멸자는 virtual로 선언해야 한다.
        -- 자식 클래스에 동적 할당이 있는 경우에 부모 클래스 참조로 자식 클래스에 접근하는 경우
            -- 이경우 소멸자에 virtual선언이 없이 delete가 될 경우 할당 해제가 안된다.
        -- 따라서 일반적으로 소멸자가 필요 없는 클래스라고 가상 소멸자를 제공해야 한다.
    
    - 프렌드
        -- 프렌드는 클래스 멤버가 아니므로 프렌드는 가상함수가 될 수 없다.
        -- 프렌드 함수가 내부적으로 가상 멤버 함수를 사용하게 한다.

    - 재정의 하지 않을경우(오버라이딩 안할경우)
        -- 부모 클래스의 함수를 사용한다.
        -- 상속의 상속의 상속, 파생의 파생의 파생 클래스인경우
            가장 최근에 정의된 함수를 사용한다.
    
    - 가상함수 재정의시 부모 클래스의 가상함수는 은닉된다.
        -- 상속된 메서드를 재정의할 경우, 오리지널과 정확하게 일치시켜야 한다.
            리턴형이 부모 클래스의 참조나 포인터형인 경우 파생클래스 형태로 대체될 수 있다.
            리턴형이 클래스형과 병행하여 바뀌는 것을 허용한다 -> 리턴형의 공변
        -- 부모 클래스에서 선언이 오버로딩 되어 있다면, 자식클래스에서는 모두 재정의 한다.
            한가지만 정의한다면 나머지 오버로딩된 함수는 은닉되어 사용할 수가 없다.
            변경할 필요가 없다면 선언만 다시 해주자.

> ### protected

    - 외부에서는 접근할 수 없지만, 상속관계에서는 접근 가능한 접근제어자
    - 가능하면 protected보다 private를 사용할 것, 상황에 따라 사용하자(언제?)

> ### 추상화 기초 클래스

    - 순수 가상 함수
        -- 함수 선언 뒤에 '=0' 을 붙인다.
        -- 순수 가상 함수가 있다면 객체를 생성 할 수 없다.
    
    - 어떤 클래스가 추상화 기초클래스가 되려면 적어도 한개의 순수 가상 함수가 존재해야 한다.
    - 추상화 기초 클래스는 특정 파생 클래스의 속성을 가지고 있는다.
    - 추상화 기초 클래스도 클래스 이기 때문에 필요한 메서드를 가지고 있을수 있다.
        -- 인터페이스의 경우 명세만 있고 구현은 없다.
    
    -  자식 클래스에서 공통된 부분을 미리 생각, 추상화 하여 부모 클래스에서 선언 이후
        자식 클래스로 책임을 위임한다.
    
    note) 인터페이스?
        클래스가 아니며, 한 개의 클래스 내에 여러개를 사용 가능하다
        - 구현 객체의 같은 동작을 보장하기 위해서이다.
        c++ 에서는 다중 상속이 되므로, 따로 인터페이스는 없이 추상 클래스만 사용한다.
    
> ### 상속과 동적 메모리 대입

    - 자식 클래스가 new를 사용하지 않는다.
        -- 
        