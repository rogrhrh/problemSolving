# chapter 12

> ### 클래스 내부에 동적할당
    
    - 클래스 생성자에 new를 사용하여 데이터를 저장할 메모리를 대입하고,
      그 메모리의 주소를 클래스 멤버에 대입(동적 배열 사용 가능)
    - 동적 할당된 클래스 멤버 메모리는 자동 해제가 되지 않는다.
    - 파괴자(소멸자)에서 delete를 사용해서 해제해 주어야 한다! 꼭!
    - delete가 있다면 객체가 소멸할때 메모리도 함께 해제된다.

> ### 특별 멤버 함수

    - 생성자를 전혀 정의하지 않았을 경우에 디폴트 생성자
    - 같은 경우의 디폴트 소멸자, 복사 생성자, 대입 연산자, 주소 연산자
    - 위의 함수들은 정의를 해주지 않을 경우 컴파일러에서 자동으로 생성한다.
    - 해당 연산들은 정의를 해주지 않아도 암시적으로 변환된다.
    
> #### 디폴트 생성자
    
    -- 아무것도 하지 않는 생성자
    -- 어떤 생성자든 정의하는 경우 디폴트 생성자는 생기지 않는다.
    -- 매개변수를 사용하지 않고 생성자를 정의한다면 명시적 디폴트 생성자를 만들 수 있다.
    note) 명시적 디폴트 생성자 이후 하나의 매개변수를 가지는
          생성자에 디폴트 매개변수를 주는 경우 모호하기에 에러가 발생한다.
    
> #### 복사 생성자

    -- 객체를 새로 생성되는 객체에 복사하는 데 사용된다.
    -- 한 객체의 값을 복사해 그 값으로 새 객체를 만든다.
    -- 프로그램이 객체의 복사본을 생성할 때마다 컴파일러는 복사 생성자를 사용한다.
    -- 함수가 객체를 값으로 전달하거나 함수가 객체를 리턴할 때 복사 생성자가 사용된다.
    -- 컴파일러는 임시 객체를 생성할 때마다 복사 생성자를 사용한다.
    
    -- 동적 할당된 멤버가 객체에 있다면 메모리를 할당하는 복사생성자가 필요하다
        --> 기본 복사 생성자는 얕은 복사로 한 메모리를 가르키는 다른 포인터가 생성된다.
        --> 원본 데이터가 소멸할 경우 복사본 데이터는 값을 잃어 문제가 생긴다.            

> ### 동적 할당된 멤버의 대입 연산

    동적 할당 멤버를 가진 객체의 유의사항
    - 한 객체를 다른 객체로 초기화 하는 경우 오류
    - 한 객체를 다른 객체에 대입할때 오류
    --> 기본 대입연산자는 동적할당인 경우 같은 메모리를 가리키게 된다.
        얕은 복사(shallow copy)
    --> 한쪽 객체가 삭제되면 메모리가 해제 되므로 다른 객체가 소멸할때
        오류가 발생한다.
    따라서 동적할당을 쓴 멤버가 있는 경우 복사 생성자와 대입 연산자를
    새로 정의 해야 한다. 깊은복사(=Deep Copy)가 되야 한다.

> ### 위치 지정 new를 사용 할 경우

    인스턴스에 메모리를 할당하지 않고, 외부에 메모리를 할당한 뒤
    인스턴스에서 해당 메모리를 가져다 쓰는 방식을 사용한다.

> #### note) nullptr

    c++98에서는 0은 숫자값 '0' 과 'null pointer'두가지 의미가 있었다.
    이를 구분하기 위해 (void*)0 처럼 사용하기도 했다.
    또는 typedef로 선언된 NULL을 사용하기도 하였다.
    c++ 11 부터 nullptr을 만들어 숫자값과 구분하여 사용한다.
    nullptr의 명시적 표현으로 컴파일러가 0과 확실히 구분할 수 있다.
    
> ### 큐 시뮬레이션

    - 큐
        -- FIFO 먼저들어온게 먼저 나간다.
        -- 추가와 삭제가 꼬리에서 들어와서 머리에서 나간다.
        -- 항목들이 도착한 순서로 보관
        -- 보관하는 항목수에 한계가 존재
        -- 비어있는 큐 생성
        -- 큐가 비었는지, 가득 차있는지 검사
        -- 꼬리 부분에 항목추가, 머리 부분에 항목 삭제
        -- 크기 확인
    Note)
        -- 구조체, 클래스, 열거체가 어떤 클래스 안에서 선언
        -- 클래스에 내포 된다고 말한다.
        -- 클래스 내부에서 사용할 수 있는 데이터 형이 된다.
        -- 사용범위 결정에 따라 외부에서도 접근 가능하다.
    
> ### 멤버 초기화 리스트
    
    - 생성자 함수 선언 뒤에 콜른(:) 이후에 멤버들을 초기화 해준다.
    - 콤마로 분리된 초기화 리스트가 나열된다.
    - 이러한 초기화는 객체 생성시 이루어진다.
    - static이 아닌 const멤버가 있을 경우 반드시 이를 활용하여 초기화한다.
    
> ### in-class 초기화
    
    - cpp 11에서 추가된 기능으로 클래스 정의에서 멤버를 초기화 할 수 있다.
    - 멤버 초기화 리스트와 동일하게 기능한다.
    - 멤버 초기화 리스트와 함게 사용될 경우 무효화 된다.
